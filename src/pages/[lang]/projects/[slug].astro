---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import type { Lang } from '../../../i18n/config';

export async function getStaticPaths() {
	const projects = await getCollection('projects');
	return projects.map((project) => {
		// Use frontmatter slug if available, otherwise extract filename from entry.slug
		const slug = project.data.slug ?? project.slug.split('/').pop() ?? project.slug;
		return {
			params: { lang: project.data.lang, slug },
		};
	});
}

const { lang, slug } = Astro.params as { lang: Lang; slug: string };
const allProjects = await getCollection('projects', (project) => project.data.lang === lang);

// Find the entry matching the slug
const entry = allProjects.find((project) => {
	const projectSlug = project.data.slug ?? project.slug.split('/').pop() ?? project.slug;
	return projectSlug === slug;
});

if (!entry) {
	throw new Error(`Project not found: ${lang}/${slug}`);
}

const { Content } = await entry.render();
const data = entry.data;
const site = Astro.site?.href ?? 'https://itkdm.com';
const canonical = new URL(`/${lang}/projects/${slug}/`, site).href;
const ogImage = '/logo.jpg';
const jsonLd = {
	'@context': 'https://schema.org',
	'@type': 'SoftwareSourceCode',
	name: data.title,
	description: data.summary,
	inLanguage: lang,
	url: canonical,
	codeRepository: data.repo,
	applicationCategory: 'DeveloperTool',
	publisher: {
		'@type': 'Organization',
		name: '布吉岛',
		logo: {
			'@type': 'ImageObject',
			url: new URL('/logo.jpg', site).href,
		},
	},
};
---

<BaseLayout
	lang={lang}
	title={data.title}
	description={data.summary}
	currentPath={`/${lang}/projects/${slug}/`}
	ogType="article"
	ogImage={ogImage}
	jsonLd={jsonLd}
>
	<article style="max-width: 800px; margin: 0 auto;">
		<header style="margin-bottom: 32px;">
			<h1 style="margin: 0 0 16px 0; font-size: clamp(28px, 4vw, 36px); font-weight: 750; letter-spacing: -0.02em; line-height: 1.3;">
				{data.icon && <span style="margin-right: 8px;">{data.icon}</span>}
				{data.title}
			</h1>
			<div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 8px; font-size: 13px; color: var(--text-muted);">
				{data.tags.length > 0 && (
					<div style="display: flex; flex-wrap: wrap; gap: 6px;">
						{data.tags.map((tag) => (
							<span class="tag">{tag}</span>
						))}
					</div>
				)}
			</div>
			{data.summary && (
				<p style="margin: 0 0 16px; font-size: 16px; color: var(--text-muted); line-height: 1.6;">
					{data.summary}
				</p>
			)}
			<div style="display: flex; flex-wrap: wrap; gap: 16px; align-items: center; margin-top: 16px;">
				<a 
					href={data.repo} 
					target="_blank" 
					rel="noreferrer"
					class="btn btn-primary project-btn-static"
					style="display: inline-flex; align-items: center; gap: 6px; text-decoration: none !important;"
				>
					<span class="dot"></span>
					<span>{lang === 'zh' ? '查看源码' : 'View Source'}</span>
				</a>
				{data.demo && (
					<a 
						href={data.demo} 
						target="_blank" 
						rel="noreferrer"
						class="btn project-btn-static"
						style="display: inline-flex; align-items: center; gap: 6px; text-decoration: none !important;"
					>
						<span>{lang === 'zh' ? '在线演示' : 'Live Demo'}</span>
					</a>
				)}
			</div>
		</header>

		<div style="border-top: 1px solid var(--border); padding-top: 32px; margin-bottom: 32px;">
			<Content />
		</div>
	</article>
	
	<style>
		.project-btn-static {
			transition: none !important;
		}
		.project-btn-static:hover {
			transform: none !important;
			box-shadow: 0 1px 0 rgba(255,255,255,.4) inset !important;
			border-color: inherit !important;
		}
		.project-btn-static:active {
			transform: none !important;
		}
	</style>

	<script define:vars={{ lang }}>
		// Add macOS-style code blocks with line numbers and copy button
		// Preserves Shiki syntax highlighting structure
		// Also handles theme-aware syntax highlighting by removing inline styles
		(function() {
			const isZh = lang === 'zh';
			const copyText = isZh ? '复制' : 'Copy';
			const copiedText = isZh ? '已复制!' : 'Copied!';
			
			// Function to apply theme-aware syntax highlighting
			// Removes ALL inline color styles and replaces with CSS variables
			function applyThemeAwareHighlighting() {
				const codeBlocks = document.querySelectorAll('article pre code, .code-block-wrapper pre code');
				
				codeBlocks.forEach((codeBlock) => {
					// Find all elements with inline color styles (spans, code, etc.)
					const coloredElements = codeBlock.querySelectorAll('[style*="color"]');
					coloredElements.forEach((el) => {
						// Skip if already processed
						if (el.hasAttribute('data-token-type')) {
							return;
						}
						const inlineStyle = el.getAttribute('style') || '';
						
						// Extract color value (RGB, hex, or named)
						const colorMatch = inlineStyle.match(/color:\s*(rgb\([^)]+\)|#[0-9a-fA-F]{3,6}|[a-zA-Z]+)/i);
						
						if (colorMatch) {
							const colorValue = colorMatch[1];
							let rgbValues = null;
							
							// Convert to RGB for matching
							if (colorValue.startsWith('rgb(')) {
								const rgbMatch = colorValue.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
								if (rgbMatch) {
									rgbValues = {
										r: parseInt(rgbMatch[1]),
										g: parseInt(rgbMatch[2]),
										b: parseInt(rgbMatch[3])
									};
								}
							} else if (colorValue.startsWith('#')) {
								// Convert hex to RGB
								const hex = colorValue.slice(1);
								const r = parseInt(hex.slice(0, 2), 16);
								const g = parseInt(hex.slice(2, 4), 16);
								const b = parseInt(hex.slice(4, 6), 16);
								rgbValues = { r, g, b };
							}
							
							if (rgbValues) {
								// Determine token type based on color similarity
								const tokenType = classifyColor(rgbValues.r, rgbValues.g, rgbValues.b);
								
								// Remove color from inline style
								const newStyle = inlineStyle
									.replace(/color:\s*(rgb\([^)]+\)|#[0-9a-fA-F]{3,6}|[a-zA-Z]+)\s*;?/gi, '')
									.trim();
								
								if (newStyle) {
									el.setAttribute('style', newStyle);
								} else {
									el.removeAttribute('style');
								}
								
								// Add data attribute for CSS targeting
								el.setAttribute('data-token-type', tokenType);
							}
						}
					});
				});
			}
			
			// Classify color into token type based on RGB values
			function classifyColor(r, g, b) {
				// Calculate color characteristics
				const max = Math.max(r, g, b);
				const min = Math.min(r, g, b);
				const delta = max - min;
				const lightness = (max + min) / 2;
				
				// Purple/Magenta (Keywords) - high red and blue, low green
				if (r > 120 && b > 120 && g < r && g < b) {
					return 'keyword';
				}
				
				// Orange/Red (Strings) - high red, medium green, low blue
				if (r > 150 && g > 100 && g < r && b < 150) {
					return 'string';
				}
				
				// Green (Comments) - high green, low red and blue
				if (g > 100 && r < 150 && b < 150) {
					return 'comment';
				}
				
				// Yellow (Functions) - high red and green, low blue
				if (r > 200 && g > 200 && b < 200) {
					return 'function';
				}
				
				// Light Green (Numbers) - balanced green and blue
				if (g > 150 && b > 100 && r < 200) {
					return 'number';
				}
				
				// Light Blue/Cyan (Variables) - high blue and green, low red
				if (b > 200 && g > 150 && r < 200) {
					return 'variable';
				}
				
				// Teal (Types) - balanced blue and green
				if (b > 150 && g > 150 && r < 150) {
					return 'type';
				}
				
				// Blue (Constants) - high blue, low red and green
				if (b > 150 && r < 150 && g < 150) {
					return 'constant';
				}
				
				// Red/Pink (Regex) - high red, low green
				if (r > 180 && g < 150 && b < 150) {
					return 'regex';
				}
				
				// Default to text color
				return 'text';
			}
			
			// Wait for content to be rendered
			function processCodeBlocks() {
				const codeBlocks = document.querySelectorAll('article pre code');
				
				codeBlocks.forEach((codeBlock) => {
					// Skip if already wrapped
					if (codeBlock.closest('.code-block-wrapper')) {
						return;
					}
					
					const pre = codeBlock.parentElement;
					if (pre.tagName !== 'PRE') return;
					
					// Get original code text for copying
					const originalText = codeBlock.textContent || '';
					
					// Create wrapper
					const wrapper = document.createElement('div');
					wrapper.className = 'code-block-wrapper';
					
					// Create header with window controls and copy button
					const header = document.createElement('div');
					header.className = 'code-block-header';
					
					// Window controls (macOS style)
					const windowControls = document.createElement('div');
					windowControls.className = 'code-window-controls';
					windowControls.innerHTML = `
						<span class="code-window-dot red"></span>
						<span class="code-window-dot yellow"></span>
						<span class="code-window-dot green"></span>
					`;
					
					// Copy button
					const copyBtn = document.createElement('button');
					copyBtn.className = 'code-copy-btn';
					copyBtn.type = 'button';
					copyBtn.setAttribute('aria-label', 'Copy code');
					copyBtn.innerHTML = `
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
							<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
						</svg>
						<span>${copyText}</span>
					`;
					
					// Copy functionality
					copyBtn.addEventListener('click', async () => {
						const text = originalText;
						
						try {
							await navigator.clipboard.writeText(text);
							copyBtn.classList.add('copied');
							copyBtn.querySelector('span').textContent = copiedText;
							
							setTimeout(() => {
								copyBtn.classList.remove('copied');
								copyBtn.querySelector('span').textContent = copyText;
							}, 2000);
						} catch (err) {
							// Fallback for older browsers
							const textarea = document.createElement('textarea');
							textarea.value = text;
							textarea.style.position = 'fixed';
							textarea.style.opacity = '0';
							document.body.appendChild(textarea);
							textarea.select();
							try {
								document.execCommand('copy');
								copyBtn.classList.add('copied');
								copyBtn.querySelector('span').textContent = copiedText;
								setTimeout(() => {
									copyBtn.classList.remove('copied');
									copyBtn.querySelector('span').textContent = copyText;
								}, 2000);
							} catch (e) {
								console.error('Failed to copy:', e);
							}
							document.body.removeChild(textarea);
						}
					});
					
					// Assemble header
					header.appendChild(windowControls);
					header.appendChild(copyBtn);
					
					// Create new pre and code elements
					const newPre = document.createElement('pre');
					const newCode = document.createElement('code');
					
					// Preserve language class if exists
					if (codeBlock.className) {
						newCode.className = codeBlock.className;
					}
					
					// Check if Shiki has syntax highlighting (has span elements)
					const hasShikiHighlighting = codeBlock.querySelector('span') !== null;
					
					// Process code content - handle both Shiki highlighted and plain code
					const textLines = originalText.split('\n');
					
					if (hasShikiHighlighting) {
						// Shiki has syntax highlighting - preserve HTML structure while adding line numbers
						// Clone the code block to work with
						const clone = codeBlock.cloneNode(true);
						
						// Process all nodes and split by line breaks
						const lines = [];
						let currentLine = [];
						
						const walkNodes = (node) => {
							if (node.nodeType === Node.TEXT_NODE) {
								const text = node.textContent;
								const parts = text.split('\n');
								
								for (let i = 0; i < parts.length; i++) {
									if (parts[i]) {
										currentLine.push(document.createTextNode(parts[i]));
									}
									if (i < parts.length - 1) {
										// End of line
										lines.push([...currentLine]);
										currentLine = [];
									}
								}
							} else if (node.nodeType === Node.ELEMENT_NODE) {
								if (node.tagName === 'BR') {
									// Line break
									lines.push([...currentLine]);
									currentLine = [];
								} else {
									// Clone element and process children
									const cloned = node.cloneNode(false);
									const savedLine = [...currentLine];
									currentLine = [];
									
									// Process children
									for (let child = node.firstChild; child; child = child.nextSibling) {
										walkNodes(child);
									}
									
									// Add accumulated children to cloned element
									currentLine.forEach(n => cloned.appendChild(n));
									currentLine = savedLine;
									currentLine.push(cloned);
								}
							}
						};
						
						// Process all nodes
						for (let child = clone.firstChild; child; child = child.nextSibling) {
							walkNodes(child);
						}
						
						// Add last line
						if (currentLine.length > 0) {
							lines.push(currentLine);
						}
						
						// Create line divs
						lines.forEach((lineNodes) => {
							const lineDiv = document.createElement('div');
							lineDiv.className = 'code-line';
							lineNodes.forEach(n => lineDiv.appendChild(n));
							newCode.appendChild(lineDiv);
						});
						
						// Fallback if no lines created
						if (newCode.children.length === 0) {
							textLines.forEach((lineText) => {
								const lineDiv = document.createElement('div');
								lineDiv.className = 'code-line';
								lineDiv.textContent = lineText;
								newCode.appendChild(lineDiv);
							});
						}
					} else {
						// No syntax highlighting, just add line numbers
						textLines.forEach((lineText) => {
							const lineDiv = document.createElement('div');
							lineDiv.className = 'code-line';
							lineDiv.textContent = lineText;
							newCode.appendChild(lineDiv);
						});
					}
					
					newPre.appendChild(newCode);
					
					// Wrap everything
					wrapper.appendChild(header);
					wrapper.appendChild(newPre);
					
					// Replace original pre with new wrapper
					pre.parentNode.replaceChild(wrapper, pre);
				});
				
				// Apply theme-aware highlighting after processing code blocks
				setTimeout(applyThemeAwareHighlighting, 50);
			}
			
			// Run immediately to prevent FOUC
			// Apply highlighting as early as possible
			function initCodeHighlighting() {
				processCodeBlocks();
				// Apply highlighting immediately, then again after a short delay
				applyThemeAwareHighlighting();
				setTimeout(applyThemeAwareHighlighting, 50);
			}
			
			// Run immediately and also on DOMContentLoaded
			if (document.readyState === 'loading') {
				// Run as early as possible
				initCodeHighlighting();
				document.addEventListener('DOMContentLoaded', () => {
					initCodeHighlighting();
				});
			} else {
				initCodeHighlighting();
			}
			
			// Also run after a short delay to catch dynamically loaded content
			setTimeout(() => {
				processCodeBlocks();
				setTimeout(applyThemeAwareHighlighting, 100);
			}, 100);
			
			// Listen for theme changes and reapply highlighting
			// Watch body element for data-theme changes
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
						// Theme changed - reapply highlighting after a short delay
						setTimeout(() => {
							applyThemeAwareHighlighting();
						}, 50);
					}
				});
			});
			
			// Observe body element for theme attribute changes
			if (document.body) {
				observer.observe(document.body, {
					attributes: true,
					attributeFilter: ['data-theme']
				});
			}
			
			// Also listen to theme button clicks directly for immediate response
			const themeBtn = document.getElementById('themeBtn');
			if (themeBtn) {
				// Use capture phase to run before other handlers
				themeBtn.addEventListener('click', () => {
					setTimeout(() => {
						applyThemeAwareHighlighting();
					}, 100);
				}, true);
			}
			
			// Fallback: periodically check for new code blocks (for dynamic content)
			setInterval(() => {
				const codeBlocks = document.querySelectorAll('article pre code, .code-block-wrapper pre code');
				let needsUpdate = false;
				codeBlocks.forEach((codeBlock) => {
					const hasInlineColors = codeBlock.querySelector('[style*="color"]:not([data-token-type])');
					if (hasInlineColors) {
						needsUpdate = true;
					}
				});
				if (needsUpdate) {
					applyThemeAwareHighlighting();
				}
			}, 1000);
		})();
	</script>
</BaseLayout>
