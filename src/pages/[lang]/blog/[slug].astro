---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import type { Lang } from '../../../i18n/config';
import Giscus from '../../../components/Giscus.astro';
import { sortBlogPosts } from '../../../lib/blog-sort';

export async function getStaticPaths() {
	const posts = await getCollection('blog');
	return posts.map((post) => {
		// Use frontmatter slug if available, otherwise extract filename from entry.slug
		const slug = post.data.slug ?? post.slug.split('/').pop() ?? post.slug;
		return {
			params: { lang: post.data.lang, slug },
		};
	});
}

const { lang, slug } = Astro.params as { lang: Lang; slug: string };
const allPosts = await getCollection('blog', (post) => post.data.lang === lang && !post.data.draft);

// Find the entry matching the slug
const entry = allPosts.find((post) => {
	const postSlug = post.data.slug ?? post.slug.split('/').pop() ?? post.slug;
	return postSlug === slug;
});

if (!entry) {
	throw new Error(`Blog post not found: ${lang}/${slug}`);
}

const { Content } = await entry.render();
const data = entry.data;
const site = Astro.site?.href ?? 'https://itkdm.com';
const canonical = new URL(`/${lang}/blog/${slug}/`, site).href;
const ogImage = data.cover?.src ?? '/logo.jpg';
const jsonLd = {
	'@context': 'https://schema.org',
	'@type': 'BlogPosting',
	headline: data.title,
	description: data.summary,
	datePublished: data.date.toISOString(),
	dateModified: data.date.toISOString(),
	inLanguage: lang,
	mainEntityOfPage: canonical,
	url: canonical,
	image: new URL(ogImage, site).href,
	publisher: {
		'@type': 'Organization',
		name: '布吉岛',
		logo: {
			'@type': 'ImageObject',
			url: new URL('/logo.jpg', site).href,
		},
	},
};

// Find previous and next posts for navigation
const sortedPosts = sortBlogPosts(allPosts);
const postsWithSlug = sortedPosts.map((post) => {
	const postSlug = post.data.slug ?? post.slug.split('/').pop() ?? post.slug;
	return { post, slug: postSlug };
});

const currentIndex = postsWithSlug.findIndex((p) => p.slug === slug);
const prevPost = currentIndex > 0 ? postsWithSlug[currentIndex - 1] : null;
const nextPost = currentIndex < postsWithSlug.length - 1 ? postsWithSlug[currentIndex + 1] : null;
---

<BaseLayout
	lang={lang}
	title={data.title}
	description={data.summary}
	currentPath={`/${lang}/blog/${slug}/`}
	ogType="article"
	ogImage={ogImage}
	jsonLd={jsonLd}
>
	<article style="max-width: 800px; margin: 0 auto;">
		<header style="margin-bottom: 32px;">
			<h1 style="margin: 0 0 16px 0; font-size: clamp(28px, 4vw, 36px); font-weight: 750; letter-spacing: -0.02em; line-height: 1.3;">
				{data.title}
			</h1>
			<div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 8px; font-size: 13px; color: var(--text-muted);">
				<time datetime={data.date.toISOString()}>{data.date.toISOString().slice(0, 10)}</time>
				{data.tags.length > 0 && (
					<div style="display: flex; flex-wrap: wrap; gap: 6px;">
						{data.tags.map((tag) => (
							<a 
								href={`/${lang}/blog/tags/${encodeURIComponent(tag)}/`} 
								class="tag tag-link"
								title={lang === 'zh' ? `查看所有「${tag}」标签的文章` : `View all posts tagged "${tag}"`}
							>
								{tag}
							</a>
						))}
					</div>
				)}
			</div>
			{data.summary && (
				<p style="margin: 0; font-size: 16px; color: var(--text-muted); line-height: 1.6;">
					{data.summary}
				</p>
			)}
		</header>

	<style>
		article header .tag-link {
			text-decoration: none !important;
			cursor: pointer;
			transition: all 0.2s ease;
		}
		article header .tag-link:hover {
			background: color-mix(in srgb, var(--primary-soft) 80%, transparent) !important;
			border-color: var(--primary) !important;
			color: var(--primary) !important;
			transform: translateY(-1px);
		}
		article header .tag-link:active {
			transform: translateY(0);
		}
		/* 文章导航链接样式 - 无背景颜色 */
		.post-nav-link {
			flex: 1;
			padding: 16px;
			border: 1px solid var(--border);
			border-radius: var(--radius-lg);
			text-decoration: none;
			color: inherit;
			transition: border-color 0.2s ease, color 0.2s ease;
		}
		.post-nav-link:hover {
			border-color: var(--primary-soft);
			color: var(--primary);
		}
	</style>

	<div style="border-top: 1px solid var(--border); padding-top: 32px; margin-bottom: 32px;">
		<Content />
	</div>

	{(prevPost || nextPost) && (
			<nav class="post-nav" style="display: flex; gap: 12px; padding-top: 24px; border-top: 1px solid var(--border); margin-top: 32px;">
				{prevPost && (
					<a href={`/${lang}/blog/${prevPost.slug}/`} class="post-nav-link">
						<div style="font-size: 12px; color: var(--text-faint); margin-bottom: 6px;">
							{lang === 'zh' ? '上一篇' : 'Previous'}
						</div>
						<div style="font-weight: 600; font-size: 14px;">{prevPost.post.data.title}</div>
					</a>
				)}
				{nextPost && (
					<a href={`/${lang}/blog/${nextPost.slug}/`} class="post-nav-link" style="text-align: right;">
						<div style="font-size: 12px; color: var(--text-faint); margin-bottom: 6px;">
							{lang === 'zh' ? '下一篇' : 'Next'}
						</div>
						<div style="font-weight: 600; font-size: 14px;">{nextPost.post.data.title}</div>
					</a>
				)}
			</nav>
		)}

		<div style="margin-top: 48px; padding-top: 32px; border-top: 1px solid var(--border);">
			<Giscus lang={lang} />
		</div>
	</article>

	<script define:vars={{ lang }}>
		// Add macOS-style code blocks with line numbers and copy button
		// Preserves Shiki syntax highlighting structure
		// Also handles theme-aware syntax highlighting by removing inline styles
		(function() {
			const isZh = lang === 'zh';
			const copyText = isZh ? '复制' : 'Copy';
			const copiedText = isZh ? '已复制!' : 'Copied!';
			const expandText = isZh ? '展开' : 'Expand';
			const collapseText = isZh ? '折叠' : 'Collapse';
			const CODE_FOLD_THRESHOLD = 30; // 超过30行才折叠
			const CODE_FOLD_LINES = 20; // 默认显示20行
			
			// Function to apply theme-aware syntax highlighting
			// Removes ALL inline color styles and replaces with CSS variables
			function applyThemeAwareHighlighting() {
				const codeBlocks = document.querySelectorAll('article pre code, .code-block-wrapper pre code');
				
				codeBlocks.forEach((codeBlock) => {
					// Find all elements with inline color styles (spans, code, etc.)
					const coloredElements = codeBlock.querySelectorAll('[style*="color"]');
					coloredElements.forEach((el) => {
						// Skip if already processed
						if (el.hasAttribute('data-token-type')) {
							return;
						}
						const inlineStyle = el.getAttribute('style') || '';
						
						// Extract color value (RGB, hex, or named)
						const colorMatch = inlineStyle.match(/color:\s*(rgb\([^)]+\)|#[0-9a-fA-F]{3,6}|[a-zA-Z]+)/i);
						
						if (colorMatch) {
							const colorValue = colorMatch[1];
							let rgbValues = null;
							
							// Convert to RGB for matching
							if (colorValue.startsWith('rgb(')) {
								const rgbMatch = colorValue.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
								if (rgbMatch) {
									rgbValues = {
										r: parseInt(rgbMatch[1]),
										g: parseInt(rgbMatch[2]),
										b: parseInt(rgbMatch[3])
									};
								}
							} else if (colorValue.startsWith('#')) {
								// Convert hex to RGB
								const hex = colorValue.slice(1);
								const r = parseInt(hex.slice(0, 2), 16);
								const g = parseInt(hex.slice(2, 4), 16);
								const b = parseInt(hex.slice(4, 6), 16);
								rgbValues = { r, g, b };
							}
							
							if (rgbValues) {
								// Determine token type based on color similarity
								const tokenType = classifyColor(rgbValues.r, rgbValues.g, rgbValues.b);
								
								// Remove color from inline style
								const newStyle = inlineStyle
									.replace(/color:\s*(rgb\([^)]+\)|#[0-9a-fA-F]{3,6}|[a-zA-Z]+)\s*;?/gi, '')
									.trim();
								
								if (newStyle) {
									el.setAttribute('style', newStyle);
								} else {
									el.removeAttribute('style');
								}
								
								// Add data attribute for CSS targeting
								el.setAttribute('data-token-type', tokenType);
							}
						}
					});
				});
			}
			
			// Classify color into token type based on RGB values
			function classifyColor(r, g, b) {
				// Calculate color characteristics
				const max = Math.max(r, g, b);
				const min = Math.min(r, g, b);
				const delta = max - min;
				const lightness = (max + min) / 2;
				
				// Purple/Magenta (Keywords) - high red and blue, low green
				if (r > 120 && b > 120 && g < r && g < b) {
					return 'keyword';
				}
				
				// Orange/Red (Strings) - high red, medium green, low blue
				if (r > 150 && g > 100 && g < r && b < 150) {
					return 'string';
				}
				
				// Green (Comments) - high green, low red and blue
				if (g > 100 && r < 150 && b < 150) {
					return 'comment';
				}
				
				// Yellow (Functions) - high red and green, low blue
				if (r > 200 && g > 200 && b < 200) {
					return 'function';
				}
				
				// Light Green (Numbers) - balanced green and blue
				if (g > 150 && b > 100 && r < 200) {
					return 'number';
				}
				
				// Light Blue/Cyan (Variables) - high blue and green, low red
				if (b > 200 && g > 150 && r < 200) {
					return 'variable';
				}
				
				// Teal (Types) - balanced blue and green
				if (b > 150 && g > 150 && r < 150) {
					return 'type';
				}
				
				// Blue (Constants) - high blue, low red and green
				if (b > 150 && r < 150 && g < 150) {
					return 'constant';
				}
				
				// Red/Pink (Regex) - high red, low green
				if (r > 180 && g < 150 && b < 150) {
					return 'regex';
				}
				
				// Default to text color
				return 'text';
			}
			
			// Wait for content to be rendered
			function processCodeBlocks() {
				const codeBlocks = document.querySelectorAll('article pre code');
				
				codeBlocks.forEach((codeBlock) => {
					// Skip if already wrapped
					if (codeBlock.closest('.code-block-wrapper')) {
						return;
					}
					
					const pre = codeBlock.parentElement;
					if (pre.tagName !== 'PRE') return;
					
					// Get original code text for copying
					const originalText = codeBlock.textContent || '';
					const textLines = originalText.split('\n');
					const totalLines = textLines.length;
					const shouldFold = totalLines > CODE_FOLD_THRESHOLD;
					
					// Create wrapper
					const wrapper = document.createElement('div');
					wrapper.className = 'code-block-wrapper';
					
					// Create header with window controls and copy button
					const header = document.createElement('div');
					header.className = 'code-block-header';
					
					// Window controls (macOS style)
					const windowControls = document.createElement('div');
					windowControls.className = 'code-window-controls';
					windowControls.innerHTML = `
						<span class="code-window-dot red"></span>
						<span class="code-window-dot yellow"></span>
						<span class="code-window-dot green"></span>
					`;
					
					// Copy button
					const copyBtn = document.createElement('button');
					copyBtn.className = 'code-copy-btn';
					copyBtn.type = 'button';
					copyBtn.setAttribute('aria-label', 'Copy code');
					copyBtn.innerHTML = `
						<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
							<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
						</svg>
						<span>${copyText}</span>
					`;
					
					// Copy functionality
					copyBtn.addEventListener('click', async () => {
						const text = originalText;
						
						try {
							await navigator.clipboard.writeText(text);
							copyBtn.classList.add('copied');
							copyBtn.querySelector('span').textContent = copiedText;
							
							setTimeout(() => {
								copyBtn.classList.remove('copied');
								copyBtn.querySelector('span').textContent = copyText;
							}, 2000);
						} catch (err) {
							// Fallback for older browsers
							const textarea = document.createElement('textarea');
							textarea.value = text;
							textarea.style.position = 'fixed';
							textarea.style.opacity = '0';
							document.body.appendChild(textarea);
							textarea.select();
							try {
								document.execCommand('copy');
								copyBtn.classList.add('copied');
								copyBtn.querySelector('span').textContent = copiedText;
								setTimeout(() => {
									copyBtn.classList.remove('copied');
									copyBtn.querySelector('span').textContent = copyText;
								}, 2000);
							} catch (e) {
								console.error('Failed to copy:', e);
							}
							document.body.removeChild(textarea);
						}
					});
					
					// Assemble header
					header.appendChild(windowControls);
					header.appendChild(copyBtn);
					
					// Create new pre and code elements
					const newPre = document.createElement('pre');
					const newCode = document.createElement('code');
					
					// Preserve language class if exists
					if (codeBlock.className) {
						newCode.className = codeBlock.className;
					}
					
					// Check if Shiki has syntax highlighting (has span elements)
					const hasShikiHighlighting = codeBlock.querySelector('span') !== null;
					
					// Process code content - handle both Shiki highlighted and plain code
					if (hasShikiHighlighting) {
						// Shiki has syntax highlighting - preserve HTML structure while adding line numbers
						// Clone the code block to work with
						const clone = codeBlock.cloneNode(true);
						
						// Process all nodes and split by line breaks
						const lines = [];
						let currentLine = [];
						
						const walkNodes = (node) => {
							if (node.nodeType === Node.TEXT_NODE) {
								const text = node.textContent;
								const parts = text.split('\n');
								
								for (let i = 0; i < parts.length; i++) {
									if (parts[i]) {
										currentLine.push(document.createTextNode(parts[i]));
									}
									if (i < parts.length - 1) {
										// End of line
										lines.push([...currentLine]);
										currentLine = [];
									}
								}
							} else if (node.nodeType === Node.ELEMENT_NODE) {
								if (node.tagName === 'BR') {
									// Line break
									lines.push([...currentLine]);
									currentLine = [];
								} else {
									// Clone element and process children
									const cloned = node.cloneNode(false);
									const savedLine = [...currentLine];
									currentLine = [];
									
									// Process children
									for (let child = node.firstChild; child; child = child.nextSibling) {
										walkNodes(child);
									}
									
									// Add accumulated children to cloned element
									currentLine.forEach(n => cloned.appendChild(n));
									currentLine = savedLine;
									currentLine.push(cloned);
								}
							}
						};
						
						// Process all nodes
						for (let child = clone.firstChild; child; child = child.nextSibling) {
							walkNodes(child);
						}
						
						// Add last line
						if (currentLine.length > 0) {
							lines.push(currentLine);
						}
						
						// Create line divs
						lines.forEach((lineNodes, index) => {
							const lineDiv = document.createElement('div');
							lineDiv.className = 'code-line';
							lineNodes.forEach(n => lineDiv.appendChild(n));
							// Hide lines beyond threshold if folding is enabled
							if (shouldFold && index >= CODE_FOLD_LINES) {
								lineDiv.style.display = 'none';
							}
							newCode.appendChild(lineDiv);
						});
						
						// Fallback if no lines created
						if (newCode.children.length === 0) {
							textLines.forEach((lineText, index) => {
								const lineDiv = document.createElement('div');
								lineDiv.className = 'code-line';
								lineDiv.textContent = lineText;
								// Hide lines beyond threshold if folding is enabled
								if (shouldFold && index >= CODE_FOLD_LINES) {
									lineDiv.style.display = 'none';
								}
								newCode.appendChild(lineDiv);
							});
						}
					} else {
						// No syntax highlighting, just add line numbers
						textLines.forEach((lineText, index) => {
							const lineDiv = document.createElement('div');
							lineDiv.className = 'code-line';
							lineDiv.textContent = lineText;
							// Hide lines beyond threshold if folding is enabled
							if (shouldFold && index >= CODE_FOLD_LINES) {
								lineDiv.style.display = 'none';
							}
							newCode.appendChild(lineDiv);
						});
					}
					
					newPre.appendChild(newCode);
					
					// Wrap everything
					wrapper.appendChild(header);
					wrapper.appendChild(newPre);
					
					// Handle code folding if needed
					if (shouldFold) {
						const codeLines = Array.from(newCode.querySelectorAll('.code-line'));
						const hiddenLines = codeLines.slice(CODE_FOLD_LINES);
						
						// Create expand/collapse button at the bottom
						const expandBtn = document.createElement('button');
						expandBtn.className = 'code-expand-btn';
						expandBtn.type = 'button';
						expandBtn.setAttribute('aria-label', expandText);
						expandBtn.innerHTML = `
							<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 16px; height: 16px; transition: transform 0.2s;">
								<polyline points="6 9 12 15 18 9"></polyline>
							</svg>
							<span>${expandText}</span>
						`;
						
						// Add fade effect at the bottom when folded
						const fadeOverlay = document.createElement('div');
						fadeOverlay.className = 'code-fade-overlay';
						fadeOverlay.style.cssText = `
							position: absolute;
							bottom: 60px;
							left: 0;
							right: 0;
							height: 50px;
							background: linear-gradient(to bottom, transparent, var(--bg));
							opacity: 0.7;
							pointer-events: none;
							transition: opacity 0.2s;
							z-index: 1;
						`;
						
						// Create button container at the bottom with gradient and blur effect
						const buttonContainer = document.createElement('div');
						buttonContainer.className = 'code-expand-btn-container';
						buttonContainer.style.cssText = `
							position: absolute;
							bottom: 0;
							left: 0;
							right: 0;
							padding: 20px 12px 12px 12px;
							text-align: center;
							background: linear-gradient(to bottom, transparent, var(--bg));
							opacity: 0.85;
							backdrop-filter: blur(8px);
							-webkit-backdrop-filter: blur(8px);
							z-index: 2;
						`;
						buttonContainer.appendChild(expandBtn);
						
						newPre.style.position = 'relative';
						newPre.appendChild(fadeOverlay);
						newPre.appendChild(buttonContainer);
						
						let isExpanded = false;
						
						expandBtn.addEventListener('click', () => {
							isExpanded = !isExpanded;
							
							if (isExpanded) {
								// Expand: show all lines
								hiddenLines.forEach(line => {
									line.style.display = '';
								});
								fadeOverlay.style.opacity = '0';
								expandBtn.querySelector('span').textContent = collapseText;
								expandBtn.querySelector('svg').style.transform = 'rotate(180deg)';
								wrapper.classList.add('expanded');
							} else {
								// Collapse: hide lines beyond threshold
								hiddenLines.forEach(line => {
									line.style.display = 'none';
								});
								fadeOverlay.style.opacity = '1';
								expandBtn.querySelector('span').textContent = expandText;
								expandBtn.querySelector('svg').style.transform = 'rotate(0deg)';
								wrapper.classList.remove('expanded');
								
								// Scroll to top of code block when collapsing
								wrapper.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
							}
						});
					}
					
					// Replace original pre with new wrapper
					pre.parentNode.replaceChild(wrapper, pre);
				});
				
				// Apply theme-aware highlighting after processing code blocks
				setTimeout(applyThemeAwareHighlighting, 50);
			}
			
			// Run immediately to prevent FOUC
			// Apply highlighting as early as possible
			function initCodeHighlighting() {
				processCodeBlocks();
				// Apply highlighting immediately, then again after a short delay
				applyThemeAwareHighlighting();
				setTimeout(applyThemeAwareHighlighting, 50);
			}
			
			// Run immediately and also on DOMContentLoaded
			if (document.readyState === 'loading') {
				// Run as early as possible
				initCodeHighlighting();
				document.addEventListener('DOMContentLoaded', () => {
					initCodeHighlighting();
				});
			} else {
				initCodeHighlighting();
			}
			
			// Also run after a short delay to catch dynamically loaded content
			setTimeout(() => {
				processCodeBlocks();
				setTimeout(applyThemeAwareHighlighting, 100);
			}, 100);
			
			// Listen for theme changes and reapply highlighting
			// Watch body element for data-theme changes
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
						// Theme changed - reapply highlighting after a short delay
						setTimeout(() => {
							applyThemeAwareHighlighting();
						}, 50);
					}
				});
			});
			
			// Observe body element for theme attribute changes
			if (document.body) {
				observer.observe(document.body, {
					attributes: true,
					attributeFilter: ['data-theme']
				});
			}
			
			// Also listen to theme button clicks directly for immediate response
			const themeBtn = document.getElementById('themeBtn');
			if (themeBtn) {
				// Use capture phase to run before other handlers
				themeBtn.addEventListener('click', () => {
					setTimeout(() => {
						applyThemeAwareHighlighting();
					}, 100);
				}, true);
			}
			
			// Fallback: periodically check for new code blocks (for dynamic content)
			setInterval(() => {
				const codeBlocks = document.querySelectorAll('article pre code, .code-block-wrapper pre code');
				let needsUpdate = false;
				codeBlocks.forEach((codeBlock) => {
					const hasInlineColors = codeBlock.querySelector('[style*="color"]:not([data-token-type])');
					if (hasInlineColors) {
						needsUpdate = true;
					}
				});
				if (needsUpdate) {
					applyThemeAwareHighlighting();
				}
			}, 1000);
		})();
	</script>
</BaseLayout>
